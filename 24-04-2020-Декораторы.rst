Декораторы, ООП (продолжение)
#############################

:date: 24-04-2020 09:00
:summary: Синтаксис Python (продолжение)
:status: published
:published: yes

.. default-role:: code

.. contents:: Содержание

Декораторы
==========

Декораторы в Python и примеры их практического использования.

Итак, что же это такое? Для того, чтобы понять, как работают декораторы, в первую очередь следует вспомнить, что функции в python являются объектами, соответственно, их можно возвращать из другой функции или передавать в качестве аргумента. Также следует помнить, что функция в python может быть определена и внутри другой функции.

Вспомнив это, можно смело переходить к декораторам. Декораторы — это, по сути, "обёртки", которые дают нам возможность изменить поведение функции, не изменяя её код.

Создадим свой декоратор "вручную":

.. code:: python

    def my_shiny_new_decorator(function_to_decorate):
        # Внутри себя декоратор определяет функцию-"обёртку". Она будет обёрнута вокруг декорируемой,
        # получая возможность исполнять произвольный код до и после неё.
        def the_wrapper_around_the_original_function():
            print("Я - код, который отработает до вызова функции")
            function_to_decorate() # Сама функция
            print("А я - код, срабатывающий после")
        # Вернём эту функцию
        return the_wrapper_around_the_original_function

    # Представим теперь, что у нас есть функция, которую мы не планируем больше трогать.
    def stand_alone_function():
        print("Я простая одинокая функция, ты ведь не посмеешь меня изменять?")

    stand_alone_function()
    # Однако, чтобы изменить её поведение, мы можем декорировать её, то есть просто передать декоратору,
    # который обернет исходную функцию в любой код, который нам потребуется, и вернёт новую,
    # готовую к использованию функцию:
    stand_alone_function_decorated = my_shiny_new_decorator(stand_alone_function)
    stand_alone_function_decorated()

Возможно мы бы хотели, чтобы каждый раз, во время вызова stand_alone_function, вместо неё вызывалась stand_alone_function_decorated. Для этого просто перезапишем stand_alone_function:

.. code:: python

    stand_alone_function = my_shiny_new_decorator(stand_alone_function)
    stand_alone_function()

Собственно, это и есть декораторы. Вот так можно было записать предыдущий пример, используя синтаксис декораторов:

.. code:: python

    @my_shiny_new_decorator
    def another_stand_alone_function():
        print("Оставь меня в покое")

    another_stand_alone_function()

То есть, декораторы в python — это просто синтаксическая обертка для конструкций вида:

.. code:: python

    another_stand_alone_function = my_shiny_new_decorator(another_stand_alone_function)

Можно использовать несколько декораций для функций:

.. code:: python

    def bread(func):
        def wrapper():
            print()
            func()
            print("<\______/>")
        return wrapper

    def ingredients(func):
        def wrapper():
            print("#помидоры#")
            func()
            print("~салат~")
        return wrapper

    def sandwich(food="--ветчина--"):
        print(food)

    sandwich()
    sandwich = bread(ingredients(sandwich))
    sandwich()

И аналогично через декораторы:

.. code:: python

    @bread
    @ingredients
    def sandwich(food="--ветчина--"):
        print(food)

    sandwich()


Не забываем, что так как порядок вызова функций имеет значение, то и порядок проставление декораторов так же имеет значение. 


Упражнение 1
------------

Напишите функцию, которая получает на вход список чисел и выдает ответ сколько в данном списке четных чисел. Напишите декоратор, который меняет поведение функции следующим образом: если четных чисел нет, то пишет "Нету(" а если их больше 10, то пишет "Очень много"

Передача декоратором аргументов в функцию
-----------------------------------------

Однако, все декораторы, которые мы рассматривали, не имели одного очень важного функционала — передачи аргументов декорируемой функции. Собственно, это тоже несложно сделать.

Текстовый данные в языке пайтон описываются классом ``str``:

.. code:: python

    def a_decorator_passing_arguments(function_to_decorate):
        def a_wrapper_accepting_arguments(arg1, arg2):
            print("Смотри, что я получил:", arg1, arg2)
            function_to_decorate(arg1, arg2)
        return a_wrapper_accepting_arguments

    # Теперь, когда мы вызываем функцию, которую возвращает декоратор, мы вызываем её "обёртку",
    # передаём ей аргументы и уже в свою очередь она передаёт их декорируемой функции
    @a_decorator_passing_arguments
    def print_full_name(first_name, last_name):
        print("Меня зовут", first_name, last_name)

    print_full_name("Vasya", "Pupkin")


Декорирование методов
---------------------

Один из важных фактов, которые следует понимать, заключается в том, что функции и методы в Python — это практически одно и то же, за исключением того, что методы всегда ожидают первым параметром ссылку на сам объект (self). Это значит, что мы можем создавать декораторы для методов точно так же, как и для функций, просто не забывая про self.

При этом строка представляет из себя объект-коллекцию и есть возможность
получить доступ к отдельным ее элементам по индексу:

.. code:: python

    def method_friendly_decorator(method_to_decorate):
        def wrapper(self, lie):
            lie -= 3
            return method_to_decorate(self, lie)
        return wrapper

    class Lucy:
        def __init__(self):
            self.age = 32
        @method_friendly_decorator
        def sayYourAge(self, lie):
            print("Мне {} лет, а ты бы сколько дал?".format(self.age + lie))

    l = Lucy()
    l.sayYourAge(-3)



Упражнение 2
------------
Воспользуйтесь написанным классом Vector2D и методом __add__. Добавьте к нему декоратор, который при вызове метода печатает сообщение вида: (1, 2) + (3, -1) = (2, 1)

А теперь попробуем написать декоратор, принимающий аргументы:

.. code:: python

    def decorator_maker():
        print("Я создаю декораторы! Я буду вызван только раз: когда ты попросишь меня создать декоратор.")
        def my_decorator(func):
            print("Я - декоратор! Я буду вызван только раз: в момент декорирования функции.")
            def wrapped():
                print ("Я - обёртка вокруг декорируемой функции.\n"
                       "Я буду вызвана каждый раз, когда ты вызываешь декорируемую функцию.\n"
                       "Я возвращаю результат работы декорируемой функции.")
                return func()
            print("Я возвращаю обёрнутую функцию.")
            return wrapped
        print("Я возвращаю декоратор.")
        return my_decorator

    # Давайте теперь создадим декоратор. Это всего лишь ещё один вызов функции
    new_decorator = decorator_maker()
    # Теперь декорируем функцию
    def decorated_function():
        print("Я - декорируемая функция.")

    decorated_function = new_decorator(decorated_function)
    # Теперь наконец вызовем функцию:
    decorated_function()

Теперь перепишем данный код с помощью декораторов:

.. code:: python

    @decorator_maker()
    def decorated_function():
        print("Я - декорируемая функция.")

    decorated_function()

Вернёмся к аргументам декораторов, ведь, если мы используем функцию, чтобы создавать декораторы "на лету", мы можем передавать ей любые аргументы, верно?


.. code:: python

    def decorator_maker_with_arguments(decorator_arg1, decorator_arg2):
        print("Я создаю декораторы! И я получил следующие аргументы:",
               decorator_arg1, decorator_arg2)
        def my_decorator(func):
            print("Я - декоратор. И ты всё же смог передать мне эти аргументы:",
                   decorator_arg1, decorator_arg2)
            # Не перепутайте аргументы декораторов с аргументами функций!
            def wrapped(function_arg1, function_arg2):
                print ("Я - обёртка вокруг декорируемой функции.\n"
                       "И я имею доступ ко всем аргументам\n"
                       "\t- и декоратора: {0} {1}\n"
                       "\t- и функции: {2} {3}\n"
                       "Теперь я могу передать нужные аргументы дальше"
                       .format(decorator_arg1, decorator_arg2,
                               function_arg1, function_arg2))
                return func(function_arg1, function_arg2)
            return wrapped
        return my_decorator

    @decorator_maker_with_arguments("Леонард", "Шелдон")
    def decorated_function_with_arguments(function_arg1, function_arg2):
        print ("Я - декорируемая функция и я знаю только о своих аргументах: {0}"
               " {1}".format(function_arg1, function_arg2))

    decorated_function_with_arguments("Раджеш", "Говард")

Таким образом, мы можем передавать декоратору любые аргументы, как обычной функции. 

Некоторые особенности работы с декораторами
    1. Декораторы несколько замедляют вызов функции, не забывайте об этом.
    2. Вы не можете "раздекорировать" функцию. Безусловно, существуют трюки, позволяющие создать декоратор, который можно отсоединить от функции, но это плохая практика. Правильнее будет запомнить, что если функция декорирована — это не отменить.
    3. Декораторы оборачивают функции, что может затруднить отладку.



Упражнение 3
------------
Напишите декоратор, который принимает в качестве аргумента путь к файлу. Если данный декоратор добавить к функции, то в указанный файл будет логироваться информация вида:
1. Время вызова функции
2. Входящие аргументы
3. Ответ return (если есть, если нет то логгировать '-')
4. Время завершения работы функции
5. Время работы функции


Краткое напоминание о том, что такое ООП
=========================================

Класс
-----

Что это?
+++++++++

**Класс** - это способ описания сущности, определяющий состояние и поведение, зависящее от этого состояния,
а также правила для взаимодействия с данной сущностью (методы и уровни доступа к переменным класса).

Зачем это нужно?
++++++++++++++++

1. Для создания сложной структуры данных со сложным поведением;
2. Для поддержки механизмов инкапсуляции, полиморфизма и наследования;
3. Для удобства. Большая задача разбивается на много функциональных блоков меньшего размера, каждый из который реализуется классом.


Объект
------

**Объект** - это конкретный экземпляр класса, поля которого проинициализированы.


.. image:: {filename}/images/lab11/classes.png

Объектно-ориентированное программирование - это методология программирования,
основанная на представлении программы в виде совокупности объектов,
каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.

Объектно-ориентированое программирование активно оперирует следующими понятиями:

Инкапсуляция
-------------

Что это и зачем?
+++++++++++++++++

**Инкапсуляция** - упаковка данных и функций в единый компонент.
В общем случае, в разных языках программирования термин «инкапсуляция» относится к одному из или обоим определениям:

    - механизм языка, позволяющий ограничить доступ одних компонентов программы к другим.
        Например, ограничивается доступ к переменным объекта класса.
        В Python, чтобы создать в классе *скрытую переменную*, такую переменную, что к ней имеют доступ
        только методы самого класса, нужно перед именем переменной поставить `__` (два подчеркивания).

        Давайте рассмотрим :
        
ПРИМЕР 1
------------
        .. code-block:: python

            # coding=UTF-8
            class TestClass:

                def __init__(self):
                    self.public_variable = "I'm public!"
                    self.__private_variable = "I'm too shy to be public!"

                def get_public_variable(self):
                    return self.public_variable

                def get_private_variable(self):
                    return self.__private_variable

            if __name__ == "__main__":
                test_class = TestClass()
                print(" ".join(["Public variable:", test_class.get_public_variable()]))
                print(" ".join(["Public variable:", test_class.public_variable]))

                print(" ".join(["Private variable:", test_class.get_private_variable()]))
                print(" ".join(["Private variable:", test_class._private_variable]))



        Если вы запустите этот код, то вы получите следующее:

        .. code-block:: python

            Public variable: I'm public!
            Private variable: I'm too shy to be public!
            Traceback (most recent call last):
              File "private_access.py", line 13, in <module>
                print(" ".join(["Private variable:", test_class._private_variable]))
            AttributeError: 'TestClass' object has no attribute '_private_variable'

        Удобство *инкапсуляции* в следующем:

        1. Безопасность: никто не может залезть внутрь класса и записать в переменные все что захочет, тем самым, сломав вашу программу;
        2. Удобство: *рефакторинг* (переписывании кода). Вы можете начать переписывать класс, переназвать переменные и вам не придется бегать по коду и менять везде `test_class.public_variable` на `test_class.new_public_variable`, вам нужно будет поменять всего одну функцию `get_public_variable`.

    - языковая конструкция, позволяющая связать данные с методами, предназначенными для обработки этих данных.
        Эта концепция очень близка к предыдущей. Давайте посмотрим на два кода:

        1.

        .. code-block:: python

            # coding=UTF-8
            class PositiveInt:
                __a = 0

                def set_a(self, a):
                    if a >=0:
                        self.__a = int(a)
                    else:
                        print("Wrong parameter, an internal state won't change." )

                def get_a(self):
                    return self.__a

            if __name__ == "__main__":
                value = PositiveInt()

                print(value.get_a())

                value.set_a(10)
                print(value.get_a())


                value.set_a(-10)
                print(value.get_a())


       2.

        .. code-block:: python

            # coding=UTF-8
            class PositiveInt:
                a = 0

            if __name__ == "__main__":
                value = PositiveInt()

                print(value.a)

                value.a = 10
                print(value.a)


                param = -10
                if param > 10:
                    value.a = param
                else:
                    print("Wrong parameter, an internal stayte won't change." )

                print(value.a)


        Собственно, оба этих кода делают одно и тоже.

        Давайте представим, что пришел код-ревьюер, который проверял ваш код на чистоту/читаемость/верность стиля
        и сказал что нужно переименовать `__a` в `__positive_integer`, потому что так по названию переменной понятней, зачем она нужна.

        То в случае кода 1 вы поменяете код в трех местах в классе `PositiveInt` и больше нигде.
        По сути, внутренности класса поменялись, но никто из тех, кто обращался к этому классу, этого не заметил.

        А в случае 2 помимо самого класса вам придется ходить по всему коду и везде менять имя переменной, что, согласитесь, не очень удобно.
        А еще это может вызвать кучу ошибок.


Абстрактный тип данных
-----------------------

Что это?
+++++++++

**Абстрактный тип данных** (АТД) -  это такой тип данных, который скрывает свою внутреннюю реализацию от клиентов. См. инкапсуляцию.

Зачем это нужно?
++++++++++++++++++

АДТ имеет следующие преимущества:

- *Инкапсуляция деталей реализации*. Это означает, что единожды инкапсулировав детали реализации работы АТД мы предоставляем клиенту *интерфейс* (методы класса, которые позволяют взаимодействовать с его непосредственным внутренним содержанием, не раскрывая его. В случае `PositiveInt` это `get_a(self)` и `set_a(self, a)`), при помощи которого он может взаимодействовать с АТД. Изменив детали реализации, представление клиентов о работе АТД не изменится.

- *Снижение сложности*. Путем абстрагирования от внутренней реализации класса мы сосредотачиваемся на интерфейсе, т.е на том, что может делать АТД, а не на том, как это делается.

- *Ограничение области использования данных*. Используя АТД, мы можем быть уверены, что данные, представляющие внутреннюю структуру АТД, не будут зависеть от других участков кода. При этом реализуется “независимость” АТД.

- *Высокая информативность интерфейса*. АТД позволяет представить весь интерфес в терминах сущностей предметной области, что, согласитесь, повышает удобочитаемость и информативность интерфейса.

Наследование
-------------

**Наследование** - это метод расширения функциональности классов и снижения дубликации кода, когда один класс полностью забирает себе (наследует) все поля и методы другого класса (класса родителя) и добавляет новые поля и методы или переопределяет старые, тем самым расширяя/изменяя функциональность класса в сравнении с классом-родителем.

Определения
++++++++++++

Рассмотрим простое наследование, пусть класс Derived --> Base. В Python 3 это осуществляется следующим кодом:

.. code-block:: python

    class Base:
        pass

    class Derived(Base):
        pass

Класс `Base` в данном случае является **базовым классом**, **родительским классом**, **надклассом**, **суперклассом**, **предком**.

Класс `Derived` по отношению к нему является **производным классом**, **дочерним классом**, **подклассом**, **потомком**.

Говорят, что `Derived` **наследует**, **расширяет** или **специализирует** `Base`.

В языке Python 3 существует единый базовый класс object, который неявно является предком всех объектов вообще.

Класс Object определяет базовые методы всех классов, они могут быть переопределены у конкретного класса..

Зачем это нужно?
+++++++++++++++++

Давайте рассмотрим 

ПРИМЕР 2
------------

когда это может понадобиться.
Классы создаются для объединения кода и функций, его обрабатывающих. Однако, несколько классов часто оказываются настолько похожими, что код приходится дублировать.

.. code-block:: python

    class Student(UniversityMember):
        group = None
        passToUniversity = ''
        status = True

        def checkStatus(self):
            return self.status

        def dismiss(self):
            self.status = False
            self.pass_to_university = None

    class Teacher(UniversityMember):
        cathedral = None
        passToUniversity = ''
        status = True

        def checkStatus(self):
            return self.status

        def dismiss(self):
            self.status = False
            self.pass_to_university = None

    class Administrator(UniversityMember):
        passToUniversity = ''
        status = True

        def checkStatus(self):
            return self.status

        def dismiss(self):
            self.status = False
            self.pass_to_university = None


В данном случае и у студента, и у преподавателя, и у администратора должны быть свойства `status` и `pass_to_university`, возможность проверки статуса и возможность увольнения.

Можно заметить, что в примере очень много дублирующегося кода. Это плохо. Если мы захотим что-то поменять, нам придется менять в трех местах как минимум.
Если забудем что-то поменять, то это приведет к ошибке. В масштабах большого программного продукта это приведет к катастрофе.


Наследование классов
+++++++++++++++++++++

Заменим дублирование кода явным **наследованием** от абстактного класса (см.АДТ) `UniversityMember`:

ПРОДОЛЖЕНИЕ ПРИМЕРА 2
------------
.. code-block:: python

    class UniversityMember:
        passToUniversity = ''
        status = True

        def checkStatus(self):
            return self.status

        def dismiss(self):
            self.status = False
            self.pass_to_university = None

    class Student(UniversityMember):
        group = None

    class Teacher(UniversityMember):
        cathedral = None

    class Administrator(UniversityMember):
        pass

Диаграмма, которая отображает отношения между классами называется **диаграммой классов**, и на ней могут быть изображены также методы и атрибуты классов.

Язык объектно-ориентированного моделирования UML_ включает в себя не только диаграммы классов, но и множество других диаграмм, позволяющих лучше представить будущую программу.

За более подробной информацией можно обратиться к Wikipedia_ или пойти в гугл.

.. _UML: https://ru.wikipedia.org/wiki/UML
.. _Wikipedia: https://ru.wikipedia.org/wiki/UML

В нашем случае при помощи UML_ отношение классов можно представить следующим образом:

.. image:: {filename}/images/lab11/example.png

И более полная версия, включающая в себя поля и методы классов:

.. image:: {filename}/images/lab11/example_uml.png

Перегрузка методов
+++++++++++++++++++

Любой метод можно **переопределить**, то есть повторно реализовать в подклассе. В этом случае для экземпляров базового класса будет вызываться базовый метод, а для экземпляров производного -- перегруженный.

.. code-block:: python

    class Base:
        def hello():
            print("Hello! I'm base class!")

    class Derived(Base):
        def hello():
            print("Hello! I'm derived class!")

    b = Base()
    d = Derived()
    b.hello()   # Hello! I'm base class!
    d.hello()   # Hello! I'm derived class!

Этот механизм называется **динамическим связыванием методов** или **полиморфизмом**.

В языке Python используется механизм грубого определения типа (утиная типизация):

    When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.

Это значит, что если нам нужно вызвать некий метод объекта, то не важно, к какому классу относится этот объект, главное, чтобы он имел метод, который предполагается вызвать.

Подстановочный критерий Барбары Лисков
+++++++++++++++++++++++++++++++++++++++++

Правильно используйте наследование!

Механизм наследования используется для моделирования отношений типа "является".

.. image:: {filename}/images/lab11/liskov.jpg

В случае с классами `Student`, `Teacher` и `Administrator` мы могли бы ошибочно сделать `Administrator` предком `Student` и `Teacher`, поскольку это позволяет сэкономить код, да и вроде бы они только расширяют его функциональность...

.. code-block:: python

    class Administrator:
        passToUniversity = ''
        status = True

        def checkStatus(self):
            return self.status

        def dismiss(self):
            self.status = False
            self.pass_to_university = None

    class Student(Administrator):
        group = None

    class Teacher(Administrator):
        cathedral = None

Однако нарушена логика: ни студент не является админстратором, ни преподаватель. При развитии проекта у администратора могут появиться некоторые новые атрибуты или методы, которые попадут в другие классы вследствие архитектурной ошибки.

Именно для того, чтобы избежать этой ошибочной логики, мы применили абстрактное мышление и придумали класс `UniversityMember`.

Подстановочный критерий Барбары Лисков гласит также, что класс-потомок не только должен уметь делать всё то же, что и предок, но и не должен требовать для этого ничего нового.

Роберт С. Мартин определил этот принцип так:

    Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.

Идея в том, чтобы выделять в отдельный класс все не специфические для объектов свойства, и наследоваться уже от этого универсального класса. Т.е. в базовый класс, от которого наследуются, могут добавляться только те поля и методы, которые нужны всем наследникам.
В таком случае, если вы возьмете функцию, которая использует класс А, возьмете класс В, который унаследован он А и передадите в эту функцию, все будет работать.

Грубо говоря, если электрик чинил розетку за рубли, то его потомок должен, во-первых, уметь чинить розетку, во-вторых, уметь получить за это рубли (а не только доллары) и, в-третьих, не требовать для выполнения своей работы предварительных "танцев с бубном" (специфических предварительных инициализаций) или передачи дополнительных параметров в виде коробки конфет или бутылки водки.

Множественное наследование
+++++++++++++++++++++++++++

При множественном наследовании у класса может быть более одного предка. В этом случае класс-потомок наследует методы всех предков.

.. code-block:: python

    class SuperBase: # Предок предка
        def do(self):
            print('Метод суперпредка!')
    class Base1(SuperBase):   # Предок 1
        def do_it(self):
            print('Метод предка 1')
    class Base2:   # Предок 2
        def do_it(self):
            print('Метод предка 2')
    class Derived(Base1, Base2):   # Наследник
        def do_it_by_myself(self):
            print('Метод наследника')

    d = Derived()   # инстанциация

    d.do_it_by_myself()  # Если в классе-потомке есть перегруженный метод с искомым названием
                         # то он будет вызван независимо от наличия таких же методов у предков.

    d.do_it() # Если такого метода нет, то он ищется в порядке "лествичного права":
              # в первую очередь у ближайших предков -- слева-направо,
              # затем у их предков в том же порядке слева-направо, пока не будет найден.
              # В данном случае будет вызван метод предка 1.

    d.do()  # Метод суперпредка вызывается, только если такого нет
            # ни у класса, ни у его ближайших предков

Полиморфизм
------------

Что это?
+++++++++

**Полиморфизм** - это способность объекта использовать методы производного класса, который не существует на момент создания базового.

Зачем это нужно?
++++++++++++++++++

Звучит сложно.

Предположим, что нам нужно три типа публикаций: новости, объявления и статьи.
В чем-то они похожи — у всех них есть заголовок и текст, у новостей и объявлений есть дата.
В чем-то они разные — у статей есть авторы, у новостей — источники, а у объявлений — дата, после которой оно становится не актуальным.

Самые простые варианты, которые приходят в голову — написать три отдельных класса и работать с ними.
Или написать один класс, в которым будут все свойства, присущие всем трем типам публикаций, а задействоваться будут только нужные.
Но ведь для разных типов аналогичные по логике методы должны работать по-разному.
Делать несколько однотипных методов для разных типов (get_news, get_announcements, get_articles), как уже обсуждалось, не есть хорошо.
Тут нам и поможет полиморфизм.


.. code-block:: python

    # coding=UTF-8

    from abc import abstractmethod


    class Publication:
        """
            Класс Publication - абстрактный.
            Абстрактный класс - это такой класс,
            который описывает названия функций и их параметры но не имеет внутри реализации.
            Как следствие, объект этого класс нельзя создать, т.к. он не доопределен.
            Но от него можно наследоваться.

            В нашем примере абстрактным методом (без реализации) мы сделали get_str при помощи @abstractmethod.
            Т.е. все потомки ОБЯЗАНЫ его реализовать. Иначе потомок тоже будет абстрактным.
            Кого интересует, может почитать про Abstract Base Classes
            https://docs.python.org/3.6/library/abc.html
        """
        __title = ""
        __text = ""

        def __init__(self, title, text):
            self.__title = title
            self.__text = text

        def get_title(self):
            return self.__title

        def get_text(self):
            return self.__text

        def set_title(self, title):
            self.__title = title

        def set_text(self, text):
            self.__text = text

        @abstractmethod
        def get_str(self):
            pass

        def __str__(self):
            return self.get_str()


    class News(Publication):
        __publication_date = ""
        __sources = []

        def __init__(self, title, text, publication_date, sources):
            super().__init__(title, text)
            self.__publication_date = publication_date

            self.set_sources(sources)

        def set_publication_date(self, publication_date):
            self.__publication_date = publication_date

        def get_publication_date(self):
            return self.__publication_date

        def set_sources(self, sources):
            if not isinstance(sources, list):
                self.__sources = [sources]
            else:
                self.__sources = sources

        def get_sources(self):
            return self.__sources

        def get_str(self):
            return " ".join(["News:", self.get_title(), "\n",
                            "Text:", self.get_text(), "\n",
                            "Publication date:", self.get_publication_date(), "\n",
                            "Sources: ", " ".join(self.get_sources()), "\n",
                            "------------------------------------------------\n"])


    class Announcement(Publication):
        __out_date = ""

        def __init__(self, title, text, out_date):
            super().__init__(title, text)
            self.__out_date = out_date

        def get_out_date(self):
            return self.__out_date

        def set_out_date(self, out_date):
            self.__out_date = out_date

        def get_str(self):
            return " ".join(["Announcement:", self.get_title(), "\n",
                            "Text:", self.get_text(), "\n",
                            "Out date:", self.get_out_date(), "\n",
                            "------------------------------------------------\n"])

    class Article(Publication):
        __authors = []

        def __init__(self, title, text, authors):
            super().__init__(title, text)
            self.set_authors(authors)

        def set_authors(self, authors):
            if not isinstance(authors, list):
                self.__authors = [authors]
            else:
                self.__authors = authors

        def get_authors(self):
            return self.__authors

        def get_str(self):
            return " ".join(["Article:", self.get_title(), "\n",
                            "Text:", self.get_text(), "\n",
                            "Authors:", ", ".join(self.get_authors()), "\n",
                            "------------------------------------------------\n"])

    if __name__ == "__main__":

        news = News("Braking news!", "That's a really exiting news!", "12 of November 2016", ["CNN", "BBC"])
        announce = Announcement("New announcement!", "I want to by an elephant!", "15 of December 2016")
        article = Article("We have new investigation", "Мы изобрели зелененький глазовыколупыватель", ["Профессор Бред",
                                                                                                       "Ассистент Капитан Очевидность"])
        strange_list = [news, announce, "Просто кусок непонятного бреда", article]

        for element in strange_list:
            if isinstance(element, Publication):
                print(element)

Метод `__str__(self)` есть у всех объектов в `Python` и вызывается когда мы пишем в коде `print(some_object)`, т.е. на самом деле, `print(some_object)` интерпретатором `Python` превращается в `some_object.__str__()`.
У каждого объекта в `Python` есть два очень похожих метода `__repr__(self)` и `__str__(self)`. Оба этих метода возвращают строку.

1. `__str__(self)` возвращает строку, которая кратко в неформальном стиле описывает объект. То, что показывается пользователю, когда он делает `print`.
2. `__repr__(self)` возвращает строку, которая полностью описывает объект. Как правило, по строке, которую возвращает `__repr__`, можно понять тип объекта и получить всю информацию о его состоянии.

Пример:

.. code-block:: python

    # coding=UTF-8
    >>> from decimal import Decimal
    >>>
    >>> a = Decimal(1.2)
    >>> print(a) # В этом случае вызовется __str__(self)
    1.2
    >>> a # А в этом __repr__(self)
    Decimal('1.2')
    >>>


Вернемся к программе выше:

Собстенно, в `Publication` есть метод `__str__(self)` внутри которого вызывается `get_str(self)`.
`get_str(self)` в `Publication` не реализован.

`get_str(self)` реализован в потомках `Publication`. Поэтому, когда мы делаем `print(element)`, то `__str__(self)` будет вызван из родителя `Publication`, потому что в детях он не переопределен.

А вот `get_str(self)` будет вызван уже из потомков, т.к. в `Publication` он не реализован.
Т.е. `Publication` использует метод, который будет определен только в потомке.
Потомок, тем самым, будет менять результат работы предка - это и есть полиморфизм, один вызов, разное поведение.

Переопределение стандартных операций
====================================

Данные методы также называют магическими (или magic methods).

Рассмотрим класс Vector, используемый для представления радиус-векторов на координатной плоскости, и определим в нем поля-координаты: x и y. Также очень хотелось бы определить для векторов операцию +, чтобы их можно было складывать столь же удобно, как и числа или строки. Например, чтобы можно было записать так:

.. code-block:: python

        A = Vector(1, 2)
        B = Vector(3, 4)
        C = A + B

Для этого необходимо перегрузить операцию +: определить функцию, которая будет использоваться, если операция + будет вызвана для объекта класса Vector. Для этого нужно определить метод __add__ класса Vector, у которого два параметра: неявная ссылка self на экземпляр класса, для которого она будет вызвана (это левый операнд операции +) и явная ссылка other на правый операнд:

.. code-block:: python

        class Vector:
            def __init__(self, x = 0, y = 0):
                self.x = x
                self.y = y
            def __add__(self, other):
                return Vector(self.x + other.x, self.y + other.y)

Теперь при вызове оператора A + B Питон вызовет метод A.__add__(B), то есть вызовет указанный метод, где self = A, other = B.

Аналогично можно определить и оставшиеся операции. Полезной для переопределения является операция <. Она должна возвращать логическое значение True, если левый операнд меньше правого или False в противном случае (также в том случае, если объекты равны). Для переопределения этого операнда нужно определить метод __lt__ (less than):

.. code-block:: python

        class Vector:
            def __lt__(self, other):
                return self.x < other.x or self.x == other.x and self.y < other.y

В этом примере оператор вернет True, если у левого операнда поле x меньше, чем у правого операнда, а также если поля x у них равны, а поле y меньше у левого операнда.

После определения оператора <, появляется возможность упорядочивать объекты, используя этот оператор. Теперь можно сортировать списки объектов при помощи метода sort() или функции sorted, при этом будет использоваться именно определенный оператор сравнения <.

Список возможных перегружаемых операторов

Следующая таблица взята из книги Саммерфильда (стр. 283 и далее).

+---------------------------------+------------------+
| Метод                           | Использование    |
+=================================+==================+
| Операторы сравнения                                |
+---------------------------------+------------------+
| __lt__(self, other)             | x < y            |
+---------------------------------+------------------+
| __le__(self, other)             | x <= y           |
+---------------------------------+------------------+
| __eq__(self, other)             | x == y           |
+---------------------------------+------------------+
| __ne__(self, other)             | x != y           |
+---------------------------------+------------------+
| __gt__(self, other)             | x > y            |
+---------------------------------+------------------+
| __ge__(self, other)             | x >= y           |
+---------------------------------+------------------+
| Арифметические операторы                           |
+----------------------------------------------------+
| Сложение                                           |
+---------------------------------+------------------+
| __add__(self, other)            | x + y            |
+---------------------------------+------------------+
| __radd__(self, other)           | y + x            |
+---------------------------------+------------------+
| __iadd__(self, other)           | x += y           |
+---------------------------------+------------------+
| Вычитание                                          |
+---------------------------------+------------------+
| __sub__(self, other)            | x - y            |
+---------------------------------+------------------+
| __rsub__(self, other)           | y - x            |
+---------------------------------+------------------+
| __isub__(self, other)           | x -= y           |
+---------------------------------+------------------+
| Умножение                                          |
+---------------------------------+------------------+
| __mul__(self, other)            | ``x * y``        |
+---------------------------------+------------------+
| __rmul__(self, other)           | ``y * x``        |
+---------------------------------+------------------+
| __imul__(self, other)           | ``x *= y``       |
+---------------------------------+------------------+
| Деление                                            |
+---------------------------------+------------------+
| __truediv__(self, other)        | x / y            |
+---------------------------------+------------------+
| __rtruediv__(self, other)       | y / x            |
+---------------------------------+------------------+
| __itruediv__(self, other)       | x /= y           |
+---------------------------------+------------------+
| Целочисленное деление                              |
+---------------------------------+------------------+
| __floordiv__(self, other)       | x // y           |
+---------------------------------+------------------+
| __rfloordiv__(self, other)      | y // x           |
+---------------------------------+------------------+
| __ifloordiv__(self, other)      | x //= y          |
+---------------------------------+------------------+
| __divmod__(self, other)         | divmod(x, y)     |
+---------------------------------+------------------+
| Остаток                                            |
+---------------------------------+------------------+
| __mod__(self, other)            | x % y            |
+---------------------------------+------------------+
| __rmod__(self, other)           | y % x            |
+---------------------------------+------------------+
| __imod__(self, other)           | x %= y           |
+---------------------------------+------------------+
| Возведение в степень                               |
+---------------------------------+------------------+
| __pow__(self, other)            | ``x ** y``       |
+---------------------------------+------------------+
| __rpow__(self, other)           | ``y ** x``       |
+---------------------------------+------------------+
| __ipow__(self, other)           | ``x **= y``      |
+---------------------------------+------------------+
| Отрицание, модуль                                  |
+---------------------------------+------------------+
| __pos__(self)                   | +x               |
+---------------------------------+------------------+
| __neg__(self)                   | -x               |
+---------------------------------+------------------+
| __abs__(self)                   | abs(x)           |
+---------------------------------+------------------+
| Преобразование к стандартным типам                 |
+---------------------------------+------------------+
| __int__(self)                   | int(x)           |
+---------------------------------+------------------+
| __float__(self)                 | float(x)         |
+---------------------------------+------------------+
| __str__(self)                   | str(x)           |
+---------------------------------+------------------+
| __round__(self, digits = 0)     | round(x, digits) |
+---------------------------------+------------------+

    
Упражнение 4
------------

Возьмите класс Vector2D. Унаследуйте от него класс NormVector2D (вектор с нормой). Сохраните методы класса Vector2D, но добавьте магический метод __abs__(self) для нормы вектора. Добавьте метрическое расстояние на основе нормы по магическому методу __truediv__(self, other) (оператор деления, /)

ПОЯСНЕНИЯ к Упражнению №4.
------------

Vector2D можно использовать из пакетного класса Python:

.. code:: python

	pip install vector-2d
	from vector_2d import Vector
	from vector_2d import VectorPolar
------------

Либо воспользуемся одним из пользовательских классов  Vector2D для  Упражнения №4. 
------------

"""vector2D.py: Vector2D class. Enabling basic vector math. """

.. code:: python

	__author__      = "Bosenko T."
	__license__ = "GPL"
	__version__ = "2.0.1-2018"
	__maintainer__ = "Bosenko T."
	__email__ = "timur-bosenko@yandex.ru"
	__status__ = "TRY"

		from random import *
		from math import *

	class Vector:
		def __init__(self, x=0, y=0):
			self.x = 0
			self.y = 0
			if isinstance(x, tuple) or isinstance(x, list):
				y = x[1]
				x = x[0]
			elif isinstance(x, Vector):
				y = x.y
				x = x.x
		
			self.set(x,y)

		@staticmethod
		def random(size=1):
			sizex = size
			sizey = size
			if isinstance(size, tuple) or isinstance(size, list):
				sizex = size[0]
				sizey = size[1]
			elif isinstance(size, Vector):
				sizex = size.x
				sizey = size.y
			return Vector(random() * sizex, random() * sizey)

		@staticmethod
		def randomUnitCircle():
			d = random()*pi
			return Vector(cos(d)*choice([1,-1]), sin(d)*choice([1,-1]))

		@staticmethod
		def distance(a, b):
			return (a - b).getLength()

		@staticmethod
		def angle(v1, v2):
	  		return acos(v1.dotproduct(v2) / (v1.getLength() * v2.getLength()))

		@staticmethod
		def angleDeg(v1, v2):
	 		 return Vector.angle(v1,v2) * 180.0 / pi
	
		def set(self, x,y):
			self.x = x
			self.y = y
	
		def toArr(self): return [self.x, self.y]
		def toInt(self): return Vector(int(self.x), int(self.y))
		def toIntArr(self): return self.toInt().toArr()

		def getNormalized(self): 
			if self.getLength() != 0:
				return self / self.getLength()
			else: return Vector(0,0)
	
		def dotproduct(self, other):
			if isinstance(other, Vector):
				return self.x * other.x + self.y * other.y
			elif  isinstance(other, tuple) or isinstance(other, list):
				return self.x * other[0] + self.y * other[1]
			else:
				return NotImplemented
		def __add__(self, other):
			if isinstance(other, Vector):
				return Vector(self.x + other.x, self.y + other.y)
			elif  isinstance(other, tuple) or isinstance(other, list):
				return Vector(self.x + other[0], self.y + other[1])
			elif isinstance(other, int) or isinstance(other, float):
				return Vector(self.x + other, self.y + other)
			else:
				return NotImplemented
		def __sub__(self, other):
			if isinstance(other, Vector):
				return Vector(self.x - other.x, self.y - other.y)
			if  isinstance(other, tuple) or isinstance(other, list):
				return Vector(self.x - other[0], self.y - other[1])
			elif isinstance(other, int) or isinstance(other, float):
				return Vector(self.x - other, self.y - other)
			else:
				return NotImplemented
		def __rsub__(self, other):
			if isinstance(other, Vector):
				return Vector(other.x - self.x, other.y - self.y)
			elif  isinstance(other, tuple) or isinstance(other, list):
				return Vector(other[0] - self.x, other[1] - self.y)
			elif isinstance(other, int) or isinstance(other, float):
				return Vector(other - self.x, other - self.y)
			else:
				return NotImplemented
		def __mul__(self, other):
			if isinstance(other, Vector):
				return Vector(self.x * other.x, self.y * other.y)
			elif  isinstance(other, tuple) or isinstance(other, list):
				return Vector(self.x * other[0], self.y * other[1])
			elif isinstance(other, int) or isinstance(other, float):
				return Vector(self.x * other, self.y * other)
			else:
				return NotImplemented
		def __div__(self, other):
			if isinstance(other, Vector):
				return Vector(self.x / other.x, self.y / other.y)
			elif  isinstance(other, tuple) or isinstance(other, list):
				return Vector(self.x / other[0], self.y / other[1])
			elif isinstance(other, int) or isinstance(other, float):
				return Vector(self.x / other, self.y / other)
			else:
				return NotImplemented
		def __rdiv__(self, other):
			if isinstance(other, Vector):
				return Vector(other.x / self.x, other.y / self.y)
			elif  isinstance(other, tuple) or isinstance(other, list):
				return Vector(other[0] / self.x, other[1] / self.y)
			elif isinstance(other, int) or isinstance(other, float):
				return Vector(other / self.x, other / self.y)
			else:
				return NotImplemented
		def __pow__(self, other):
			if isinstance(other, int) or isinstance(other, float):
				return Vector(self.x ** other, self.y ** other)
			else:
				return NotImplemented
	
		def __iadd__(self, other):
			if isinstance(other, Vector):
				self.x += other.x
				self.y += other.y
				return self
			elif  isinstance(other, tuple) or isinstance(other, list):
				self.x += other[0]
				self.y += other[1]
				return self
			elif isinstance(other, int) or isinstance(other, float):
				self.x += other
				self.y += other
				return self
			else:
				return NotImplemented
		def __isub__(self, other):
			if isinstance(other, Vector):
				self.x -= other.x
				self.y -= other.y
				return self
			elif  isinstance(other, tuple) or isinstance(other, list):
				self.x -= other[0]
				self.y -= other[1]
				return self
			elif isinstance(other, int) or isinstance(other, float):
				self.x -= other
				self.y -= other
				return self
			else:
				return NotImplemented
		def __imul__(self, other):
			if isinstance(other, Vector):
				self.x *= other.x
				self.y *= other.y
				return self
			elif  isinstance(other, tuple) or isinstance(other, list):
				self.x *= other[0]
				self.y *= other[1]
				return self
			elif isinstance(other, int) or isinstance(other, float):
				self.x *= other
				self.y *= other
				return self
			else:
				return NotImplemented
		def __idiv__(self, other):
			if isinstance(other, Vector):
				self.x /= other.x
				self.y /= other.y
				return self
			elif  isinstance(other, tuple) or isinstance(other, list):
				self.x /= other[0]
				self.y /= other[1]
				return self
			elif isinstance(other, int) or isinstance(other, float):
				self.x /= other
				self.y /= other
				return self
			else:
				return NotImplemented
		def __ipow__(self, other):
			if isinstance(other, int) or isinstance(other, float):
				self.x **= other
				self.y **= other
				return self
			else:
				return NotImplemented
	
		def __eq__(self, other):
			if isinstance(other, Vector):
				return self.x == other.x and self.y == other.y
			else:
				return NotImplemented
		def __ne__(self, other):
			if isinstance(other, Vector):
				return self.x != other.x or self.y != other.y
			else:
				return NotImplemented
		def __gt__(self, other):
			if isinstance(other, Vector):
				return self.getLength() > other.getLength()
			else:
				return NotImplemented
		def __ge__(self, other):
			if isinstance(other, Vector):
				return self.getLength() >= other.getLength()
			else:
				return NotImplemented
		def __lt__(self, other):
			if isinstance(other, Vector):
				return self.getLength() < other.getLength()
			else:
				return NotImplemented
		def __le__(self, other):
			if isinstance(other, Vector):
				return self.getLength() <= other.getLength()
			else:
				return NotImplemented
	
		def __eq__(self, other):
			if isinstance(other, Vector):
				return self.x == other.x and self.y == other.y
			else:
				return NotImplemented
	
		def __len__(self):
			return int(sqrt(self.x**2 + self.y**2))
		def getLength(self):
			return sqrt(self.x**2 + self.y**2)
		
		def __getitem__(self, key):
			if key == "x" or key == "X" or key == 0 or key == "0":
				return self.x
			elif key == "y" or key == "Y" or key == 1 or key == "1":
				return self.y
	
		def __str__(self): return "[x: %(x)f, y: %(y)f]" % self
		def __repr__(self): return "{'x': %(x)f, 'y': %(y)f}" % self

		def __neg__(self): return Vector(-self.x, -self.y)


SOLID — принципы объекто-ориентированного программирования
==========================================================

SOLID это аббре­ви­а­тура пяти основ­ных прин­ци­пов про­ек­ти­ро­ва­ния в объ­ектно-ори­ен­ти­ро­ван­ном про­грам­ми­ро­ва­нии — Single responsibility, Open-closed, Liskov substitution, Interface segregation и Dependency inversion (прин­ципы един­ствен­ной ответ­ствен­но­сти, откры­то­сти / закры­то­сти, под­ста­новки Бар­бары Лис­ков, раз­де­ле­ния интер­фейса и инвер­сии зависимостей)
Аббре­ви­а­тура SOLID была пред­ло­жена Робер­том Мар­ти­ном, авто­ром несколь­ких книг, широко извест­ных в сооб­ще­стве разработчиков. Эти прин­ципы поз­во­ляют стро­ить на базе ООП мас­шта­би­ру­е­мые и сопро­вож­да­е­мые про­грамм­ные про­дукты с понят­ной биз­нес-логи­кой.

Рас­шиф­ров­ка:

Single responsibility (прин­цип един­ствен­ной ответ­ствен­но­сти)
Open-closed (прин­цип откры­то­сти / закры­то­сти)
Liskov substitution (прин­цип под­ста­новки Бар­бары Лис­ков)
Interface segregation (прин­цип раз­де­ле­ния интер­фейса)
Dependency inversion (прин­цип инвер­сии зави­си­мо­стей)
Прин­цип един­ствен­ной обя­зан­но­сти / ответ­ствен­но­сти (single responsibility principle) обо­зна­ча­ет, что каж­дый объ­ект дол­жен иметь одну обя­зан­ность и эта обя­зан­ность должна быть пол­но­стью инкап­су­ли­ро­вана в класс. Все его сер­висы должны быть направ­лены исклю­чи­тельно на обес­пе­че­ние этой обя­зан­но­сти.

Прин­цип откры­то­сти / закры­то­сти декларирует, что про­грамм­ные сущ­но­сти (клас­сы, моду­ли, функ­ции и т. п.) должны быть открыты для рас­ши­ре­ния, но закрыты для изме­не­ния. Это озна­ча­ет, что эти сущ­но­сти могут менять свое пове­де­ние без изме­не­ния их исход­ного кода.

Прин­цип под­ста­новки Бар­бары Лис­ков (Liskov substitution) в фор­му­ли­ровке Роберта Мар­ти­на: «функ­ции, кото­рые исполь­зуют базо­вый тип, должны иметь воз­мож­ность исполь­зо­вать под­типы базо­вого типа не зная об этом».

Прин­цип раз­де­ле­ния интер­фейса (interface segregation) в фор­му­ли­ровке Роберта Мар­ти­на: «кли­енты не должны зави­сеть от мето­дов, кото­рые они не исполь­зуют». Прин­цип раз­де­ле­ния интер­фей­сов гово­рит о том, что слиш­ком «тол­стые» интер­фейсы необ­хо­димо раз­де­лять на более малень­кие и спе­ци­фи­че­ские, чтобы кли­енты малень­ких интер­фей­сов знали только о мето­дах, кото­рые необ­хо­димы им в рабо­те. В ито­ге, при изме­не­нии метода интер­фейса не должны меняться кли­енты, кото­рые этот метод не исполь­зуют.

Прин­цип инвер­сии зави­си­мо­стей (dependency inversion) — модули верх­них уров­ней не должны зави­сеть от моду­лей ниж­них уров­ней, а оба типа моду­лей должны зави­сеть от абстрак­ций; сами абстрак­ции не должны зави­сеть от дета­лей, а вот детали должны зави­сеть от абстракций.



Декораторы @classmethod и @staticmethod
=======================================
Существуют 2 особенных декоратора, которые можно повесить на функции внутри класса. 
@staticmethod определяет обычную функцию в пространстве имён класса. Может быть полезно для вспомогательных _* функций, чтобы не мусорить пространство имён модуля.

@classmethod создаёт метод класса. Объект класса явно передаётся через первый параметр как это с параметром self происходит для обычных методов. Также как и для self, переданный cls может отличаться от класса, в котором определён класс-метод (может быть потомок). Часто используется для создания альтернативных конструкторов.

Если мы взглянем на пример кода, в котором показано, как работает декоратор, это может помочь понять основные принципы:

ПРИМЕР №3
------------
.. code-block:: python

    class Person: 
        def __init__(self, name, age): 
            self.name = name 
            self.age = age 
          
        # classmethod чтобы создать объект по году рождения, 
        # "альтернативный" конструктор
        @classmethod
        def fromBirthYear(cls, name, year): 
            return cls(name, date.today().year - year) 
          
        # статический метод,чтобы проверить совершеннолетие
        @staticmethod
        def isAdult(age): 
            return age > 18
      
    person1 = Person('Петя', 21) 
    person2 = Person.fromBirthYear('Петя', 1996) 
      
    print person1.age 
    print person2.age 
      
    # print the result 
    print Person.isAdult(22) 


.. parsed-literal::

    21
    21
    True

Важно понимать, что ни classmethod ни staticmethod НЕ являются функциями от конкретного объекта класса и соответственно не принимают self. Подчеркнем еще раз их различия:
    1. classmethod принимает cls как первый параметр, тогда как staticmethod в специальных аргументах не нуждается
    2. classmethod может получать доступ или менять состояние класса, в то время как staticmethod нет
    3. staticmethod в целом вообще ничего не знают про класс. Это просто функция над аргументами, объявленная внутри класса.


Упражнение 5
------------
Добавьте в класс Vector2D classmethod .copy(vector), который принимает объект класса Vector2D и создает на основе него новый вектор с такими же параметрами. Добавьте классовый метод .fromlist(list), который принимает список из двух элементов, которые соответствуют x и y.

Упражнение 6
------------
Создайте внутренний атрибут класса, обозначающий норму самого большого вектора. Создайте classmethod Vector2d.get_biggest_size() возвращающий норму самого длинного вектора.




