Паттерны проектирования. Декоратор и наблюдатель.
#################################################

:date: 2020-05-15 09:00
:summary: Паттерны проектирования. Декоратор и наблюдатель.
:status: published
:published: no

.. default-role:: code

.. contents:: Содержание

.. role:: python(code)
   :language: python

.. table_of_contest

Паттерны проектирования
=======================

При проектировании больших приложений, очень удобно использовать уже существующие паттерны проектирования, а не изобретать каждый раз велосипед.

Паттерн (шаблон) проектирования (от англ. design pattern) — повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста.

Как и где применять паттерн — целиком и полностью Ваша ответственность. В данном уроке мы познакомимся с некоторыми из них. Стоит отметить, что паттерны проектирования пришли в программирование из архитектуры, где они не получили широкого распространения. Все паттерны делятся на несколько групп:

#. Основные шаблоны
#. Порождающие шаблоны — шаблоны, абстрагирующие процесс инстанцирования.
#. Структурные шаблоны — определяют различные сложные структуры, изменяющие интерфейс существующих объектов или его реализацию, позволяя облегчить разработку и оптимизировать программу.
#. Поведенческие шаблоны — определяют взаимодействие между объектами, увеличивая их гибкость.

Паттерн Decorator
=================

Проблема
-----------------
Паттерн Декоратор (Decorator) — структурный шаблон проектирования, предназначенный для динамического подключения дополнительного поведения к объекту.

Описание взято с https://refactoring.guru/ru/design-patterns/decorator

Представьте, что вы работаете над библиотекой оповещений, которую можно подключать к разнообразным программам, чтобы получать уведомления о важных событиях.

Основой библиотеки является класс Notificator с методом send, который принимает на вход строку-сообщение и высылает её всем администраторам по электронной почте. Сторонняя программа должна создать и настроить этот объект, указав кому отправлять оповещения, а затем использовать его каждый раз, когда что-то случается.

.. image:: https://refactoring.guru/images/patterns/diagrams/decorator/problem1-ru.png
   :width: 560
   :align: center

В какой-то момент стало понятно, что одних email-оповещений пользователям мало. Некоторые из них хотели бы получать извещения о критических проблемах через SMS. Другие хотели бы получать их в виде сообщений Facebook. Корпоративные пользователи хотели бы видеть сообщения в Slack.

.. image:: https://refactoring.guru/images/patterns/diagrams/decorator/problem2.png
   :width: 480
   :align: center


Сначала вы добавили каждый из этих типов оповещений в программу, унаследовав их от базового класса Notificator. Теперь пользователь выбирал один из типов оповещений, который и использовался в дальнейшем.

Но затем кто-то резонно спросил, почему нельзя выбрать несколько типов оповещений сразу? Ведь если вдруг в вашем доме начался пожар, вы бы хотели получить оповещения по всем каналам, не так ли?

Вы попытались реализовать все возможные комбинации подклассов оповещений. Но после того как вы добавили первый десяток классов, стало ясно, что такой подход невероятно раздувает код программы.

.. image:: https://refactoring.guru/images/patterns/diagrams/decorator/problem3.png
   :width: 630
   :align: center

Итак, нужен какой-то другой способ комбинирования поведения объектов, который не приводит к взрыву количества подклассов.

Решение
-----------------

Наследование — это первое, что приходит в голову многим программистам, когда нужно расширить какое-то существующее поведение. Но механизм наследования имеет несколько досадных проблем.

- Он статичен. Вы не можете изменить поведение существующего объекта. Для этого вам надо создать новый объект, выбрав другой подкласс.
- Он не разрешает наследовать поведение нескольких классов одновременно. Из-за этого вам приходится создавать множество подклассов-комбинаций для получения совмещённого поведения.

Одним из способов обойти эти проблемы является механизм композиции. Это когда один объект содержит ссылку на другой и делегирует ему работу, вместо того чтобы самому наследовать его поведение. Как раз на этом принципе построен паттерн Декоратор.

Декоратор имеет альтернативное название — обёртка (вспоминте, как вы "оборачивали" функции в прошлых работах). Оно более точно описывает суть паттерна: вы помещаете целевой объект в другой объект-обёртку, который запускает базовое поведение объекта, а затем добавляет к результату что-то своё.

Оба объекта имеют общий интерфейс, поэтому для пользователя нет никакой разницы, с каким объектом работать — чистым или обёрнутым. Вы можете использовать несколько разных обёрток одновременно — результат будет иметь объединённое поведение всех обёрток сразу.

В примере с оповещениями мы оставим в базовом классе простую отправку по электронной почте, а расширенные способы отправки сделаем декораторами.

.. image:: https://refactoring.guru/images/patterns/diagrams/decorator/solution2.png
   :width: 640
   :align: center

Сторонняя программа, выступающая клиентом, во время первичной настройки будет заворачивать объект оповещений в те обёртки, которые соответствуют желаемому способу оповещения.

Последняя обёртка в списке и будет тем объектом, с которым клиент будет работать в остальное время. Для остального клиентского кода, по сути, ничего не изменится, ведь все обёртки имеют точно такой же интерфейс, что и базовый класс оповещений.

Таким же образом можно изменять не только способ доставки оповещений, но и форматирование, список адресатов и так далее. К тому же клиент может «дообернуть» объект любыми другими обёртками, когда ему захочется.

Пример
-----------------
Рассмотрете пример из `файла`__. Он содержит простой пример реалзиации декоратора на питоне.

.. __: {filename}/code/lab13/decorator.ipynb


Задача №1
---------

Представьте себя ненадолго разработчиком компьютерной игры в стиле фэнтези.
Вы будете прописывать систему эффектов, которые могут быть наложены на героя вашей игры.

У вас есть герой, который обладает некоторым набором характеристик. Враги и союзники могут накладывать на героя положительные и отрицательные эффекты. Эти эффекты каким-то образом изменяют характеристики героя. На героя можно накладывать бесконечно много эффектов, действие одинаковых эффектов суммируется. Игрок должен знать, какие положительные и какие отрицательные эффекты на него были наложены и в каком порядке.

Класс герой описан следующим образом (характеристики могут быть другими):

.. code-block:: python

    class Hero:
        def __init__(self):
            self.positive_effects = []
            self.negative_effects = []            
            self.stats = {
                "HP": 128,
                "MP": 42,
                "SP": 100,
                "Strength": 15,
                "Perception": 4,
                "Endurance": 8,
                "Charisma": 2,
                "Intelligence": 3,
                "Agility": 8,
                "Luck": 1
            } 
            
        def get_positive_effects(self):
            return self.positive_effects.copy()
        
        def get_negative_effects(self):
            return self.negative_effects.copy()
        
        def get_stats(self):
            return self.stats.copy()

Вам нужно написать систему декораторов, представленную на UML-диаграмме:

![Image Alt](https://github.com/BosenkoTM/OOAP-2020/blob/master/pictures/decorator_scheme.jpg)

Названия наложенных положительных и отрицательных эффектов добавляются каждое в свой счетчик. Названия эффектов совпадают с названиями классов.

Описания эффектов:

- **Берсерк** — Увеличивает параметры *Сила*, *Выносливость*, *Ловкость*, *Удача* на 7; уменьшает параметры *Восприятие*, *Харизма*, *Интеллект* на 3. Количество единиц здоровья увеличивается на 50.
- **Благословение** — Увеличивает все основные характеристики на 2.
- **Слабость** — Уменьшает параметры *Сила*, *Выносливость*, *Ловкость* на 4.
- **Сглаз** — Уменьшает параметр *Удача* на 10.
- **Проклятье** — Уменьшает все основные характеристики на 2.
К основным характеристикам относятся Сила (Strength), Восприятие (Perception), Выносливость (Endurance), Харизма (Charisma), Интеллект (Intelligence), Ловкость (Agility), Удача (Luck).

При выполнении задания учитывайте, что:

- Изначальные характеристики базового объекта не должны меняться.
- Изменения характеристик и накладываемых эффектов (баффов/дебаффов) должно происходить динамически, то есть при запросе `get_stats`, `get_positive_effects`, `get_negative_effects`
- Абстрактные классы `AbstractPositive`, `AbstractNegative` и соответственно их потомки могут принимать любой параметр base при инициализации объекта (`__init__(self, base)`)
- Проверяйте, что эффекты корректно снимаются, в том числе и из середины стека

**Решение**:

.. code-block:: python

    class AbstractEffect(Hero, ABC):
        def __init__(self, base):
            self.base = base

        @abstractmethod
        def get_positive_effects(self):
            return self.positive_effects

        @abstractmethod
        def get_negative_effects(self):
            return self.negative_effects

        @abstractmethod
        def get_stats(self):
            pass


    class AbstractPositive(AbstractEffect):
        def get_negative_effects(self):
            return self.base.get_negative_effects()


    class AbstractNegative(AbstractEffect):    
        def get_positive_effects(self):
            return self.base.get_positive_effects()


    class Berserk(AbstractPositive):    
        def get_stats(self):
            stats = self.base.get_stats()
            stats["HP"] += 50
            stats["Strength"] += 7
            stats["Endurance"] += 7
            stats["Agility"] += 7
            stats["Luck"] += 7
            stats["Perception"] -= 3
            stats["Charisma"] -= 3
            stats["Intelligence"] -= 3
            return stats

        def get_positive_effects(self):
            return self.base.get_positive_effects() + ["Berserk"]


    class Blessing(AbstractPositive):    
        def get_stats(self):
            stats = self.base.get_stats()
            stats["Strength"] += 2
            stats["Endurance"] += 2
            stats["Agility"] += 2
            stats["Luck"] += 2
            stats["Perception"] += 2
            stats["Charisma"] += 2
            stats["Intelligence"] += 2
            return stats

        def get_positive_effects(self):
            return self.base.get_positive_effects() + ["Blessing"]


    class Weakness(AbstractNegative):    
        def get_stats(self):
            stats = self.base.get_stats()
            stats["Strength"] -= 4
            stats["Endurance"] -= 4
            stats["Agility"] -= 4
            return stats

        def get_negative_effects(self):
            return self.base.get_negative_effects() + ["Weakness"]


    class Curse(AbstractNegative):
        def get_stats(self):
            stats = self.base.get_stats()
            stats["Strength"] -= 2
            stats["Endurance"] -= 2
            stats["Agility"] -= 2
            stats["Luck"] -= 2
            stats["Perception"] -= 2
            stats["Charisma"] -= 2
            stats["Intelligence"] -= 2
            return stats

        def get_negative_effects(self):
            return self.base.get_negative_effects() + ["Curse"]


    class EvilEye(AbstractNegative):
        def get_stats(self):
            stats = self.base.get_stats()
            stats["Luck"] -= 10
            return stats

        def get_negative_effects(self):
            return self.base.get_negative_effects() + ["EvilEye"]



Паттерн Observer 
=================

Паттерн Наблюдатель (Observer) — это поведенческий паттерн проектирования, который создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах.

Проблема
-----------------

Представьте, что вы имеете два объекта: Покупатель и Магазин. В магазин вот-вот должны завезти новый товар, который интересен покупателю.

Покупатель может каждый день ходить в магазин, чтобы проверить наличие товара. Но при этом он будет злиться, без толку тратя своё драгоценное время.

.. image:: https://refactoring.guru/images/patterns/content/observer/observer-comic-1.png
   :width: 600
   :align: center

С другой стороны, магазин может разослать спам каждому своему покупателю. Многих это расстроит, так как товар специфический, и не всем он нужен.

Получается конфликт: либо покупатель тратит время на периодические проверки, либо магазин тратит ресурсы на бесполезные оповещения.

Решение
-----------------

Давайте называть Издателями те объекты, которые содержат важное или интересное для других состояние. Остальные объекты, которые хотят отслеживать изменения этого состояния, назовём Подписчиками.

Паттерн Наблюдатель предлагает хранить внутри объекта издателя список ссылок на объекты подписчиков, причём издатель не должен вести список подписки самостоятельно. Он предоставит методы, с помощью которых подписчики могли бы добавлять или убирать себя из списка.

.. image:: https://refactoring.guru/images/patterns/diagrams/observer/solution1-ru.png
   :width: 470
   :align: center

Теперь самое интересное. Когда в издателе будет происходить важное событие, он будет проходиться по списку подписчиков и оповещать их об этом, вызывая определённый метод объектов-подписчиков.

Издателю безразлично, какой класс будет иметь тот или иной подписчик, так как все они должны следовать общему интерфейсу и иметь единый метод оповещения.

.. image:: https://refactoring.guru/images/patterns/diagrams/observer/solution2-ru.png
   :width: 460
   :align: center

Увидев, как складно всё работает, вы можете выделить общий интерфейс, описывающий методы подписки и отписки, и для всех издателей. После этого подписчики смогут работать с разными типами издателей, а также получать оповещения от них через один и тот же метод.

Пример
-----------------
Рассмотрете пример из `файла`__. Он содержит простой пример реалзиации декоратора на питоне.

.. __: {filename}/code/lab13/Observer.ipynb


Задача №2
-------------

ППродолжая работу над игрой, вы добрались до системы достижений. Иногда игре нужно наградить игрока за то, что он достигает определенного результата в игре. Это может быть, например, прохождение всех заданий в игре, достижение определенного уровня, совершение какого-то сложного действия и т.д.

У каждой игры есть движок и интерфейс пользователя. Это два компонента, которые работают параллельно и взаимодействуют друг с другом. Достижения генерируются движком игры, а отображаются пользовательским интерфейсом. Кроме того, на современных игровых площадках, таких как Steam, Google Play, также отображаются достижения, полученные игроком. Для этого применяется как раз паттерн Наблюдатель.

У вас есть движок Engine, который может создавать уведомления о достижениях. Вам необходимо написать обертку над движком, которая будет иметь возможность подписывать наблюдателей и рассылать им уведомления, а также иерархию наблюдателей. В иерархию наблюдателей должны входить абстрактный наблюдатель, `AbstractObserver`, от которого унаследованы 2 наблюдателя `ShortNotificationPrinter` и `FullNotificationPrinter`. Первый из них составляет множество названий полученных достижений, второй составляет список достижений в том порядке, в котором они даны в системе. Имейте в виду, что каждое достижение должно быть учтено только один раз.

Иерархия классов приведена на следующей UML диаграмме:

![observer](../pictures/observer_scheme.jpg)

Пример достижения, которое генерирует движок:

.. code-block:: python

    {"title": "Покоритель", "text": "Дается при выполнении всех заданий в игре"}

Метод `update` не должен возвращать никаких значений, он должен только изменять переменную `achievements`.

Класс `Engine` реализовывать не нужно!

**Решение**:

.. code-block:: python

    from abc import ABC, abstractmethod


    class ObservableEngine(Engine):
        def __init__(self):
            self.__subscribers = set()

        def subscribe(self, subscriber):
            self.__subscribers.add(subscriber)

        def unsubscribe(self, subscriber):
            self.__subscribers.remove(subscriber)

        def notify(self, message):
            for subscriber in self.__subscribers:
                subscriber.update(message)


    class AbstractObserver(ABC):
        @abstractmethod
        def update(self, message):
            pass


    class ShortNotificationPrinter(AbstractObserver):
        def __init__(self):
            self.achievements = set()

        def update(self, message):
            self.achievements.add(message['title'])


    class FullNotificationPrinter(AbstractObserver):
        def __init__(self):
            self.achievements = list()

        def update(self, message):
            if message not in self.achievements:
                self.achievements.append(message)

